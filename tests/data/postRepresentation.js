"use strict";

const JSONRepresentation = require('../../index.js').JSONRepresentation;
let posts = require('./blogStorage.js');
module.exports = (mode) => {
    return class PostRepresentation extends JSONRepresentation {
        constructor (requestBody, requestAuth) {
            super({
                "type": "object",
                "properties": {
                    "id": {
                        "type": "number",
                        "roadsReadOnly": true,
                        "resolve": (models) => {
                            return models.id;
                        }
                    },
                    "title": {
                        "type": "string",
                        "resolve": (models) => {
                            return models.title;
                        },
                        "set": (models, title, requestAuth) => {
                            models.title = title;
                        }
                    },
                    "post": {
                        "type": "string"
                    },
                    /* Trying to test to see if the new error system works properly on nested values. We are prepending a slash to solve the current naming weirdness
                    but I don't think that will work for the following.*/
                    // TODO: Update all responses to reflect this nested response. We should keep it for future testing, and ensure the response generation accurate.
                    // Then once those responses are updated, we will have a couple of broken required field tests we need to further debug. Can we get the pointers to work??
                    // IDEA: MAYBE WE NEED TO MERGE THE SCHEMA POINTER AND THE MISSING FIELD?? DOES SCHEMA POINTER POINT TO NESTING LIST INSTEAD OF ROOT??? I THINK THIS IS IT!
                    "nestingTest": {
                        "type": "object",
                        "properties": {
                            "nestedField": {
                                "type": "string",
                                "resolve": (models) => {
                                    return "nestedValue";
                                },
                                "set": (models, nestedField, requestAuth) => {
                                    // do nothing, never set this value
                                }
                            }
                        },
                        "required": mode==="append" ? ['nestedField'] : []
                    }
                },
                "additionalProperties": false,
                "required": mode === "append" ? ['title', 'post', 'nestingTest'] : []
            }, undefined, {
                resolve: (models, auth, key) => {
                    return models[key];
                },
                set: (models, requestBody, auth, key) => {
                    models[key] = requestBody;
                }
            });

            this.setRequestBody(requestBody);
        }

        append (models, auth) {
            let post = new posts.Post();
            this.applyEdit(post, auth);
            // Note: this may be auto generated by the db or something. I do this here to mimic that
            post.id = models.posts[models.posts.length - 1].id + 1; 
            models.posts.push(post);
            post.save();
            return post;
        }
    };
};